![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769096356244-56a195c9-ab4d-4986-a061-cb6130a92855.png)

![功能分析](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769173877771-1c54277d-f742-460d-9ce4-556284f1ee1b.png)![接口设计](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769173892587-29b4e82b-6a3a-40d0-91d0-44e36e954df6.png)

#### 需求分析

首先看需求，分析对应的接口，在进一步分析对应的接口

![接口的需求](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769174146186-69adcd46-0b4c-4703-b3e5-05bfad7aa682.png)

现在开始一个一个分析接口，如图为例，“查询登录用户所有地址”接口，分析该接口三大要素请求地址、请求参数（就是看哪些数据需要从前端传来，就是DTO），返回数据（就是VO）

#### dto的设计

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769179023638-cf068e58-ef85-4685-8ea4-a7170b50d3ac.png)

#### Controller的书写

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769175895192-6caaff14-346c-4009-9667-f0bac39c2775.png)

书写Controller类在对应地址，完成业务逻辑，方法的书写是三大要素请求地址GetMapping、请求参数——无，返回数据是一个存放AddressBook对象的list集合

当访问/user/addressBook/list地址后，就执行改方法，先获取当前用户的id（通过前端传来JWT），然后将调用addressBookService方法，把修改id后的addressBook对象传入

#### Service的书写

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769176347841-48c472db-456f-4e7c-8f34-8dd7d992301c.png?x-oss-process=image%2Fcrop%2Cx_0%2Cy_0%2Cw_1005%2Ch_184)

就是和Controller类方法差不多，但是需要传参，经由Serviceimpl类重写

#### Serviceimpl的书写

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769176622204-b5b008a3-cbcf-492c-8cfd-525c4340ab75.png)

具体实现逻辑都在impl类下写，此时是AddressBookService的list方法就是调用Mapper查询list的方法并返回

#### Mapper的书写

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769176767083-fd47b6f7-2c69-49b6-9d8c-fe93fa6ce1d7.png)

具体实现在xml

#### Mapper对应的xml的书写

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1769176751089-8692ca72-613a-448a-b5d6-ec09604d711f.png)

修改类型是list，参数和返回值类型是AddressBook，根据逻辑进行查询