### Controller

 在SpringBoot 项目中，Controller 包（通常命名为 `com.xxx.controller`）是**前端请求与后端业务逻辑之间的桥梁**，核心作用是接收前端的 HTTP 请求、解析参数，**然后调用 Service 层处理业务（即调用Service中的方法）**，最后返回响应结果。 

**Controller 包的典型内容**

| **内容类型**             | **说明**                                                     |
| ------------------------ | ------------------------------------------------------------ |
| 控制器类（XXController） | 核心，用 `@RestController`/`@Controller` 注解标记，处理具体的 HTTP 请求 |
| 请求映射注解             | `@GetMapping`/`@PostMapping`/`@PutMapping`/`@DeleteMapping` 等，绑定请求路径和方法 |
| 参数接收                 | 处理前端传递的参数（如 `@RequestParam`、`@PathVariable`、`@RequestBody`） |
| 响应返回                 | 返回 JSON 数据、页面、状态码等（`@RestController` 直接返回 JSON，`@Controller` 需配合 `@ResponseBody`） |
| 简单参数校验 / 异常处理  | 基础的参数合法性检查，或简单的异常捕获（复杂校验 / 异常建议抽离到专门的类） |

###  Config  

 核心作用是：**替代传统的 XML 配置**，通过 Java 代码的方式完成各类配置（框架、组件、业务规则），让配置更灵活、易维护  

 简单理解：原本需要在 `xml` 文件里写的配置（比如数据库连接、Feign 超时、拦截器），现在都可以放在 config 包的类中，Spring 启动时会自动扫描并加载这些配置。  

以下是 config 包中最常见的配置类型，结合具体示例能更直观理解：

| **配置类型**      | **说明**                                                  |
| ----------------- | --------------------------------------------------------- |
| 第三方组件配置    | OpenFeign、MyBatis、Redis、Swagger 等组件的自定义配置     |
| 框架核心配置      | 拦截器、过滤器、跨域配置、事务管理器、Bean 自定义装配等   |
| 业务相关配置      | 全局常量、自定义规则（如雪花算法生成 ID）、配置属性绑定等 |
| 环境 / 多配置适配 | 不同环境（开发 / 测试 / 生产）的配置切换、配置属性读取等  |

### DAO

**核心作用**：专门负责和数据库交互，执行增删改查（CRUD）操作，是项目中 “直接操作数据库的唯一入口”。Controller 和 Service 都不直接碰数据库，所有数据库操作都交给 DAO 层。

**典型内容**

| **内容类型**               | **说明**                                                     |
| -------------------------- | ------------------------------------------------------------ |
| DAO 接口（XXDao/XXMapper） | 核心，定义数据库操作方法，无业务逻辑                         |
| 注解 / XML                 | `@Mapper`（MyBatis 注解）、SQL 注解（`@Select`/`@Insert`）或 MyBatis XML 映射文件 |
| 分页 / 条件查询            | 处理复杂查询的参数（如 PageHelper 分页、动态 SQL）           |

**示例（PaymentDao 接口，MyBatis 风格）**

```
package com.example.demo.dao;

import com.example.demo.entities.Payment;
import org.apache.ibatis.annotations.Insert;
import org.apache.ibatis.annotations.Mapper;
import org.apache.ibatis.annotations.Select;

import java.util.List;

// 标记为MyBatis的Mapper接口，让Spring能扫描到并创建实现类
@Mapper
public interface PaymentDao {

    // 新增支付记录
    @Insert("INSERT INTO t_payment(serial, amount, status) VALUES(#{serial}, #{amount}, #{status})")
    int create(Payment payment);

    // 根据ID查询支付记录
    @Select("SELECT * FROM t_payment WHERE id = #{id}")
    Payment getPaymentById(Long id);

    // 查询所有支付记录
    @Select("SELECT * FROM t_payment")
    List<Payment> listAll();
}
```

### Service

**核心作用**：承上启下，接收 Controller 层的调用，整合 DAO 层的数据库操作，处理**核心业务逻辑**（比如判断、计算、事务控制等）。这是项目的 “大脑”，所有业务规则（比如支付时要先查余额、再扣减、最后生成流水）都在这里实现。

**典型内容**

| **内容类型**                    | **说明**                                                   |
| ------------------------------- | ---------------------------------------------------------- |
| Service 接口（XXService）       | 定义业务方法（面向接口编程，解耦）                         |
| Service 实现类（XXServiceImpl） | 实现接口，编写具体业务逻辑，注入 DAO 层对象                |
| 事务注解                        | `@Transactional`（控制事务，比如支付失败时回滚数据库操作） |
| 异常处理                        | 业务异常的抛出和处理（比如余额不足时抛自定义异常）         |

**示例（PaymentService 接口 + 实现类）**

```
// 第一步：Service接口
package com.example.demo.service;

import com.example.demo.entities.Payment;
import java.util.List;

public interface PaymentService {
    // 创建支付记录
    int createPayment(Payment payment);
    // 根据ID查询支付记录（用于负载均衡示例）
    Payment getPaymentById(Long id);
    // 查询所有支付记录
    List<Payment> listAllPayments();
}

// 第二步：Service实现类
package com.example.demo.service.impl;

import com.example.demo.dao.PaymentDao;
import com.example.demo.entities.Payment;
import com.example.demo.service.PaymentService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;

// 标记为Service组件，让Spring管理
@Service
// 事务注解：该类下所有方法执行失败时回滚
@Transactional
public class PaymentServiceImpl implements PaymentService {

    // 注入DAO层对象（Spring自动创建实例）
    @Autowired
    private PaymentDao paymentDao;

    @Override
    public int createPayment(Payment payment) {
        // 这里可以加业务逻辑：比如校验金额是否大于0
        if (payment.getAmount().compareTo(BigDecimal.ZERO) <= 0) {
            throw new RuntimeException("支付金额不能小于等于0");
        }
        // 调用DAO层操作数据库
        return paymentDao.create(payment);
    }

    @Override
    public Payment getPaymentById(Long id) {
        // 简单查询，无复杂业务
        return paymentDao.getPaymentById(id);
    }

    @Override
    public List<Payment> listAllPayments() {
        return paymentDao.listAll();
    }
}
```

### dto

 包存放**数据传输对象**，用于 “接口入参 / 跨模块数据传递”，只包含业务需要的字段，避免暴露多余数据  

**存放内容**

- 接口入参 DTO（如`UserLoginDTO`、`OrderCreateDTO`）；
- 跨服务 / 模块传输 DTO（如`UserInfoTransferDTO`）；
- 字段按需定义（只包含交互需要的字段）；
- 可添加参数校验注解（如`@NotBlank`、`@Pattern`）。

```
package com.example.dto;

import lombok.Data;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;

// 用户登录接口的入参DTO（只包含登录需要的字段）
@Data
public class UserLoginDTO {
    // 用户名不能为空
    @NotBlank(message = "用户名不能为空")
    private String username;

    // 密码不能为空
    @NotBlank(message = "密码不能为空")
    private String password;

    // 无需包含id、createTime等数据库字段，因为登录不需要
}

// 创建订单接口的入参DTO
@Data
public class OrderCreateDTO {
    // 商品ID列表
    private Long[] productIds;
    // 收货地址ID
    @NotBlank(message = "收货地址ID不能为空")
    private Long addressId;
    // 支付方式（1-支付宝，2-微信）
    private Integer payType;
}
```

### Entities

**核心作用**：封装业务数据，对应数据库中的表结构，是整个项目中 “数据的载体”。可以把它理解成：数据库里的一张表 → Entities 里的一个类 → 类的一个对象 → 表中的一行数据。

**典型内容**

| **内容类型**            | **说明**                                                     |
| ----------------------- | ------------------------------------------------------------ |
| 实体类（XXEntity/XXPO） | 核心，每个类对应数据库一张表，属性对应表的字段               |
| 注解                    | `@Entity`（JPA 用）、`@Data`（Lombok，简化 get/set）、`@Table`（指定表名）等 |
| 辅助方法                | 通常用 Lombok 注解替代手动写的 get/set、toString、构造方法   |

**示例（Payment 实体类）**

```
package com.example.demo.entities;

import lombok.Data;
import javax.persistence.Id;
import javax.persistence.Table;
import java.math.BigDecimal;

// Lombok注解，自动生成get/set、toString、equals等方法
@Data
// 指定对应数据库的表名（如果类名和表名一致可省略）
@Table(name = "t_payment")
public class Payment {
    // 主键
    @Id
    private Long id;
    // 支付流水号
    private String serial;
    // 支付金额
    private BigDecimal amount;
    // 支付状态（0：未支付，1：已支付）
    private Integer status;
}
```

### vo

 存放**视图对象**，用于 “前端展示 / 接口返回”，是定制化的数据载体 —— 可以整合多个`entity`/`dto`的字段，也可以格式化字段（如把性别码转为文字）  

- 接口返回 VO（如`UserVO`、`OrderDetailVO`）；
- 前端页面展示 VO（如`HomePageVO`）；
- 字段按前端需求定制（可包含格式化后的字段、关联表字段）；
- 不包含敏感字段（如密码）。

```
package com.example.vo;

import lombok.Data;
import java.time.LocalDateTime;

// 用户信息返回VO（给前端展示，隐藏敏感字段，格式化字段）
@Data
public class UserVO {
    private Long userId; // 前端习惯叫userId，而非数据库的id
    private String username; // 用户名
    private String genderDesc; // 性别描述（男/女/未知），而非数据库的gender码
    private String phone; // 手机号（可脱敏，如138****1234）
    private LocalDateTime createTime; // 创建时间（前端直接展示）
    // 无password字段，避免敏感信息泄露
    // 可添加关联信息，如用户所属角色名称
    private String roleName;
}

// 订单详情VO（整合订单、商品、用户多表信息）
@Data
public class OrderDetailVO {
    private String orderNo; // 订单编号
    private String productName; // 商品名称（来自product表）
    private Integer productNum; // 购买数量
    private Long totalPrice; // 订单总价
    private String payTypeDesc; // 支付方式描述（支付宝/微信）
    private String orderStatusDesc; // 订单状态描述（待支付/已支付）
    private String receiverName; // 收货人姓名（来自address表）
}
```

### dto、entities和vo的区别及口诀

| **维度** | **entity**               | **dto**                      | **vo**                   |
| -------- | ------------------------ | ---------------------------- | ------------------------ |
| 核心用途 | 映射数据库表，持久化     | 接口入参 / 跨模块传输        | 前端展示 / 接口返回      |
| 字段来源 | 完全对应数据库表字段     | 按需选择（业务需要）         | 定制化（可整合多表）     |
| 敏感字段 | 包含（如密码、主键）     | 只包含必要字段               | 不包含（隐藏敏感信息）   |
| 字段格式 | 原始数据（如性别码）     | 原始数据（便于传输）         | 格式化数据（如性别文字） |
| 注解类型 | 数据库框架注解（@Table） | 参数校验注解（@NotBlank）    | 无特殊注解（按需格式化） |
| 典型命名 | UserEntity、OrderEntity  | UserLoginDTO、OrderCreateDTO | UserVO、OrderDetailVO    |

**核心口诀**

**“entity 映库表，dto 传数据，vo 给前端看”**

**口诀拆解**

1. **entity 映库表**：`entity`的核心是**映射数据库表**，字段和数据库表一一对应，是数据持久化的载体，记住 “映库表” 就知道它和数据库强绑定；
2. **dto 传数据**：`dto`的核心是**传输数据**，专门用于接口入参、跨模块 / 跨系统传递数据，只带业务需要的字段，记住 “传数据” 就知道它是交互的 “快递盒”；
3. **vo 给前端看**：`vo`的核心是**给前端展示**，定制化字段（格式化、整合、隐藏敏感信息），记住 “给前端看” 就知道它是前端能直接用的 “展示版数据”。

### annotation

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768749437662-7feb5efc-599f-4dab-8616-4ffed733f65a.png)

 专门用来存放项目中**自定义的注解**（Annotation）相关代码，而非 Java 自带的内置注解  

次包一般包含以下内容：

**自定义注解类（核心）**

这是包内最主要的文件，用`@interface`关键字定义，用于描述业务场景的自定义注解。

```
package com.example.annotation;

import java.lang.annotation.*;

// 自定义一个“权限校验”注解
@Target(ElementType.METHOD) // 注解作用在方法上
@Retention(RetentionPolicy.RUNTIME) // 运行时保留，可通过反射获取
@Documented // 生成文档时包含该注解
public @interface RequirePermission {
    // 注解的属性：需要的权限编码
    String value() default "";
    // 注解的可选属性：是否忽略校验
    boolean ignore() default false;
}
```

**注解的 “元注解”**

元注解是用来修饰自定义注解的注解（如上面的`@Target`、`@Retention`），但这类注解一般是 Java 内置的（`java.lang.annotation`包下），不会放在自定义的`annotation`包中；不过如果项目有自定义元注解（极少场景），也会放在这个包下。

`@Target`、`@Retention`的解释如下：

```
@Target(ElementType.METHOD)//Target注解指定加上什么上面
@Retention(RetentionPolicy.RUNTIME)//Retention注解指定什么时候用，
```

**注解的配套工具类**

如果需要对注解进行解析、校验等操作，相关工具类也可放在此包下（或单独放`annotation.utils`子包），比如：

```
package com.example.annotation;

import java.lang.reflect.Method;

// 注解解析工具类
public class AnnotationParser {
    // 解析方法上的RequirePermission注解
    public static String getRequiredPermission(Method method) {
        RequirePermission annotation = method.getAnnotation(RequirePermission.class);
        return annotation != null ? annotation.value() : "";
    }
}
```

### utils

 是项目中**最常用的约定俗成包名**，专门存放各类通用、可复用、无业务侵入性的工具类。它的核心作用是抽离重复代码、简化业务逻辑、提高开发效率，就像工具箱一样，存放项目各处都会用到的 “通用小工具”。  

也就是说 **不依赖具体业务逻辑，可直接在不同模块 / 项目中复用**

通常存放的内容：

-  处理字符串、集合、日期、数字等基础类型的通用方法
-  处理文件、网络、加密、反射、JSON 解析等通用功能  
-  对 Spring、MyBatis、Redis 等框架的 API 进行二次封装，简化使用方式，降低耦合  

### enumeration

他的类的数据类型都是枚举enum

专门存放自定义的枚举类（Enum Class）。它的核心作用是统一管理项目中的枚举类型，把分散的枚举集中归类  

- 枚举**类**命名：遵循 “语义 + Enum” 的规则（如`OrderStatusEnum`），避免简单命名（如`OrderEnum`）
- 枚举**项**命名：全大写，单词间用下划线分隔（如`PENDING_PAYMENT`），语义要清晰

### aspect

专门存放切面相关代码的约定俗成包名，核心作用是实现面向切面编程

简单来说，`aspect`包就像项目的 “**通用拦截器** / 增强器”，负责**处理那些需要在多个业务方法中重复执行的逻辑。**

**通常存放的内容 :**

**切面类**

这是包内最主要的文件，用`@Aspect`注解标记，包含**切入点（Pointcut）** 和**通知（Advice）** 两部分：

- **切入点**：定义 “哪些方法需要被拦截”（如所有`@Log`注解的方法、所有`service`包下的方法）；
- **通知**：定义 “拦截后要执行的逻辑”（如方法执行前记录日志、执行后统计耗时、抛出异常时记录错误）。

```
package com.example.aspect;

import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

// 1. @Aspect标记这是一个切面类
// 2. @Component让Spring扫描并管理这个类
@Aspect
@Component
@Slf4j // 简化日志输出
public class LogAspect {

    // ========== 1. 定义切入点 ==========
    // 方式1：匹配注解（拦截所有加了@RequirePermission的方法）
    @Pointcut("@annotation(com.example.annotation.RequirePermission)")
    public void permissionPointcut() {}

    // 方式2：匹配包/类/方法（拦截service包下所有公共方法）
    @Pointcut("execution(public * com.example.service..*(..))")
    public void serviceMethodPointcut() {}

    // ========== 2. 定义通知（增强逻辑） ==========
    // 前置通知：方法执行前执行
    @Before("serviceMethodPointcut()")
    public void beforeServiceMethod() {
        log.info("【前置通知】业务方法开始执行...");
    }

    // 环绕通知：最灵活的通知，可控制方法执行前后/异常/返回
    @Around("permissionPointcut()")
    public Object aroundPermissionMethod(ProceedingJoinPoint joinPoint) throws Throwable {
        // 1. 执行前：记录请求信息、校验权限
        String methodName = joinPoint.getSignature().getName();
        log.info("【环绕通知-前】开始校验权限，方法名：{}", methodName);

        // 2. 执行原业务方法
        Object result = null;
        try {
            result = joinPoint.proceed(); // 调用被拦截的方法
            // 3. 执行后：记录成功信息
            log.info("【环绕通知-后】权限校验通过，方法执行成功，返回值：{}", result);
        } catch (Exception e) {
            // 4. 异常时：记录错误信息
            log.error("【环绕通知-异常】方法{}执行失败：{}", methodName, e.getMessage(), e);
            throw e; // 抛出异常，不影响原业务逻辑
        }
        return result;
    }

    // 后置通知：方法执行后（无论是否异常）执行
    @After("serviceMethodPointcut()")
    public void afterServiceMethod() {
        log.info("【后置通知】业务方法执行结束（无论成功/失败）");
    }
}
```

**按业务场景拆分的切面类**

实际项目中，会按功能拆分多个切面类，让职责更清晰，这是`aspect`包的典型结构：

```
package com.example.aspect;

// 1. 日志切面：处理所有日志记录逻辑
@Aspect
@Component
public class LogAspect { /* 日志记录逻辑 */ }

// 2. 权限切面：处理接口权限校验逻辑
@Aspect
@Component
public class PermissionAspect { /* 权限校验逻辑 */ }

// 3. 性能监控切面：统计方法执行耗时
@Aspect
@Component
public class PerformanceAspect {
    @Around("execution(* com.example.service..*(..))")
    public Object monitorPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        // 记录开始时间
        long startTime = System.currentTimeMillis();
        // 执行原方法
        Object result = joinPoint.proceed();
        // 计算耗时
        long costTime = System.currentTimeMillis() - startTime;
        // 记录耗时（超过1秒则告警）
        String methodName = joinPoint.getSignature().getName();
        if (costTime > 1000) {
            log.warn("【性能告警】方法{}执行耗时{}ms，超过阈值1000ms", methodName, costTime);
        } else {
            log.info("【性能监控】方法{}执行耗时{}ms", methodName, costTime);
        }
        return result;
    }
}

// 4. 事务切面（Spring自带事务注解@Transactional底层也是切面，自定义事务逻辑可放这里）
@Aspect
@Component
public class TransactionAspect { /* 自定义事务逻辑 */ }
```

**配套辅助类**

如果切面逻辑复杂，可在包内添加辅助类，比如：

```
package com.example.aspect;

// 切面通用工具类：解析请求参数、获取用户信息等
public class AspectUtils {
    // 获取当前请求的用户ID
    public static Long getCurrentUserId() {
        // 从ThreadLocal/Spring Security等上下文获取用户信息
        return 1L; // 示例值
    }

    // 解析方法参数，拼接成日志字符串
    public static String getMethodParams(ProceedingJoinPoint joinPoint) {
        Object[] args = joinPoint.getArgs();
        if (args == null || args.length == 0) {
            return "无参数";
        }
        StringBuilder params = new StringBuilder();
        for (Object arg : args) {
            params.append(arg.toString()).append(", ");
        }
        return params.substring(0, params.length() - 2);
    }
}
```

**总结**

| **术语**            | **通俗解释**                                                 | **对应代码示例**                                       |
| ------------------- | ------------------------------------------------------------ | ------------------------------------------------------ |
| 切面（Aspect）      | 横切逻辑的载体（即`@Aspect`标记的类）                        | `LogAspect`类                                          |
| 切入点（Pointcut）  | 定义 “拦截哪些方法”                                          | `@Pointcut("execution(* com.example.service..*(..))")` |
| 通知（Advice）      | 定义 “拦截后做什么”，分 5 种类型：- @Before：方法执行前- @After：方法执行后（无论异常）- @AfterReturning：方法成功执行后- @AfterThrowing：方法抛出异常后- @Around：环绕（最灵活，可控制方法执行） | `@Around("permissionPointcut()")`                      |
| 连接点（JoinPoint） | 被拦截的方法 / 位置（如某个 service 方法）                   | `ProceedingJoinPoint joinPoint`                        |

### constant

 是项目中**专门存放各类常量**的约定俗成包名，核心作用是**统一管理项目中所有固定不变的值**

- 通用全局常量（全项目复用），这类常量是项目所有模块都能用到的基础值，比如状态码、通用正则、字符编码等
- 业务模块常量（绑定特定业务），这类常量是某个业务模块专属的，比如订单、用户、支付相关的固定值，是`constant`包中占比最高的内容
-  枚举关联常量 