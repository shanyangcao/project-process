## 登录失败跳转回 login 页面后丢失样式

**核心原因：相对路径 vs 绝对路径**

假设你的登录页 URL 是 `http://localhost:8080/login`，登录失败后跳转的 URL 可能变成了 `http://localhost:8080/user/login`（取决于你的 Controller 映射路径）。

- 如果静态资源用了**相对路径**（如 `css/style.css`），浏览器会根据当前 URL 拼接路径：


- - 原 URL（`/login`）下，浏览器会请求 `http://localhost:8080/css/style.css`（正确）；
  - 跳转后 URL（`/user/login`）下，浏览器会请求 `http://localhost:8080/user/css/style.css`（错误，因为资源不在 `user` 目录下）。

**解决办法：统一使用 “绝对路径” 引用静态资源**

**1. 若使用 Thymeleaf 模板（推荐）**

必须用 `th:href` 或 `th:src` 配合 `@{/xxx}` 语法（**以** `**/**` **开头**），表示从项目根目录开始查找资源：

**html**

预览

```
<!-- 正确引用 CSS -->
<link rel="stylesheet" th:href="@{/css/style.default.premium.css}">

<!-- 正确引用 JS -->
<script th:src="@{/js/front.js}"></script>

<!-- 正确引用图标/SVG -->
<svg><use xlink:th:href="@{/icons/orion-svg-sprite.svg#real-estate-1}"></use></svg>
```

`@{/css/...}` 中的 `/` 会自动对应到项目的静态资源根目录（如 `static/css/`），无论当前 URL 是什么，路径都不会错。

**2. 若未使用模板引擎（纯 HTML）**

直接在资源路径前加 `/`，表示从项目根目录开始：

**html**

预览

```
<link rel="stylesheet" href="/css/style.default.premium.css">
<script src="/js/front.js"></script>
<svg><use xlink:href="/icons/orion-svg-sprite.svg#real-estate-1"></use></svg>
```

**额外检查：登录失败的跳转路径是否正确**

确保登录失败时，后端跳转的是 **`login` 视图 **（对应 `/login` 路径），而不是其他路径：

**java**

运行

```
@PostMapping("/user/login")
public String login(...) {
    if (登录失败) {
        model.addAttribute("errorMsg", "密码错误");
        return "login"; // 直接返回 login 视图（对应 /login 路径）
    }
}
```

避免跳转路径变成 `/user/login` 这种多级路径，减少路径层级变化带来的问题。

## 返回重定向而不是视图

**1.** `**return "dashboard"**`**：直接返回视图名称（转发机制）**

当你写 `return "dashboard"` 时，Spring MVC 会通过**视图解析器**（默认是 Thymeleaf 或 JSP 解析器）去查找名为 `dashboard` 的视图文件。

- 例如，若使用 Thymeleaf，它会在 `src/main/resources/templates` 目录下找 `dashboard.html` 文件，然后**转发**到该页面（URL 不会变化，还是原来的 `/user/login`）。
- 这种方式适用于**不需要改变浏览器 URL**，且页面需要共享请求域数据（如 `Model` 中的数据）的场景。

**2.** `**return "redirect:/main.html"**`**：重定向到指定 URL（浏览器跳转）**

而 `return "redirect:/main.html"` 是**重定向机制**，它会让浏览器向 `/main.html` 这个 URL 发起新的请求。

- 结合你配置的 `registry.addViewController("/main.html").setViewName("dashboard")`，当浏览器请求 `/main.html` 时，Spring 会直接返回 `dashboard` 视图（即 `dashboard.html` 页面）。
- 重定向的特点是**浏览器 URL 会发生变化**（变成 `/main.html`），且请求域中的数据（如 `Model`）会丢失（因为是新请求）。

**为什么这里要用重定向而不是直接返回视图名称？**

通常在**登录成功后**，推荐用**重定向**，原因有两个：

- **避免表单重复提交**：如果直接转发，用户刷新页面时可能会重复提交登录表单，导致逻辑异常；而重定向是新请求，刷新不会重复提交。
- **URL 语义化**：登录成功后跳转到 “仪表盘页面”，用 `/main.html` 这样的 URL 更直观，也符合用户对 “登录后进入主页” 的认知。

**总结**

- `return "dashboard"`：**转发**到 `dashboard.html` 页面，URL 不变，可携带请求域数据。
- `return "redirect:/main.html"`：**重定向**到 `/main.html` URL，由该 URL 映射到 `dashboard.html` 页面，URL 会变化，且请求域数据丢失。

## **未使用正确的字段名** `birth`

Employee类中字段名是 `**lastname**`（全小写），但在Thymeleaf模板中你使用的是 `**lastName**`（驼峰命名）。

**问题原因**

Lombok的 `@Data` 注解会根据字段名生成getter/setter方法：

- 字段 `lastname` → 生成 `getLastname()` 和 `setLastname()`
- 不是 `getLastName()`

**解决方案**

**方案：修正Thymeleaf模板中的字段名**

在 `emp/tables.html` 中将 `lastName` 改为 `lastname`：

```
<tr th:each="emp:${emps}">
                    <td th:text="${emp.getId()}"></td>
                    <td th:text="${emp.getLastname()}"></td>
                    <td th:text="${emp.getEmail()}"></td>
                    <td th:text="${emp.getGender()==0?'女':'男'}"></td>
                    <td th:text="${emp.getDepartment().getDepartmentName()}"></td>
                    <td th:text="${#dates.format(emp.getBirth(),'yyyy-MM-dd HH:mm:ss')}"></td>
                    <td>
                      <a class="btn btn-sm btn-primary">编辑</a>
                      <a class="btn btn-sm btn-danger">删除</a>
                    </td>
```

## 获取前端请求参数不一致

**1. 参数的含义**

- `**@RequestParam("loginUsername")**`：表示要获取的前端请求参数的**名称是** `**loginUsername**`（即前端表单或请求中必须有一个名为 `loginUsername` 的参数）。
- `**String username**`：后端方法中接收该参数的变量，类型为 `String`，变量名 `username` 仅在后端使用，与前端参数名无关（前端只认 `loginUsername`）。

**2. 对前端的要求（参数如何传递）**

前端必须通过以下方式传递名为 `loginUsername` 的参数，后端才能正确接收：

**（1）表单提交（最常见）**

**html**

预览

```
<!-- 登录表单示例 -->
<form action="/user/login" method="post">
    <!-- 输入框的 name 属性必须是 loginUsername -->
    <input type="text" name="loginUsername" placeholder="用户名">
    <input type="password" name="loginPassword" placeholder="密码">
    <button type="submit">登录</button>
</form>
```

- 关键：输入框的 `name="loginUsername"` 必须与 `@RequestParam("loginUsername")` 中的名称完全一致（大小写敏感）。

**（2）URL 拼接参数（GET 请求）**

如果是 GET 请求，参数可以直接拼在 URL 中：

**plaintext**

```
http://localhost:8080/user/login?loginUsername=admin&loginPassword=123456
```

- 此时 `loginUsername=admin` 会被 `@RequestParam("loginUsername")` 捕获，赋值给 `username` 变量。

**3. 对后端的要求（注解的可选配置）**

`@RequestParam` 有几个常用属性，控制参数的可选性和默认值：

**（1）**`required`**：参数是否必填（默认** `true`**）**

- 默认情况下，如果前端没传 `loginUsername` 参数，会直接报错（400 Bad Request）。
- 若允许参数可选，可设置 `required=false`：**java**运行

```
// 允许 loginUsername 为空，此时 username 可能为 null
@RequestParam(value = "loginUsername", required = false) String username
```

**（2）**`defaultValue`**：参数的默认值**

如果前端没传参数，可使用默认值（此时 `required` 会自动变为 `false`）：

**java**

运行

```
// 若前端没传 loginUsername，默认值为 "guest"
@RequestParam(value = "loginUsername", defaultValue = "guest") String username
```

**（3）**`value`**：指定参数名（可省略）**

`@RequestParam("loginUsername")` 等价于 `@RequestParam(value = "loginUsername")`，当注解中只有参数名时，`value` 可省略。

## 如何处理提交空表单问题

**步骤 1：在**`**addEmp**`**方法中添加参数校验和错误提示**

修改`@PostMapping("/add")`的`addEmp`方法，对`Employee`的关键字段（如姓名、邮箱、部门等）进行非空判断，若为空则返回错误提示到页面。

**java**

运行

```
@PostMapping("/add")
public String addEmp(Employee employee, Model model) {
    // 定义错误信息变量
    String errorMsg = null;
    
    // 校验姓名非空
    if (employee.getLastName() == null || employee.getLastName().trim().isEmpty()) {
        errorMsg = "姓名不能为空";
    } 
    // 校验邮箱非空
    else if (employee.getEmail() == null || employee.getEmail().trim().isEmpty()) {
        errorMsg = "邮箱不能为空";
    } 
    // 校验部门非空（通过department.id判断）
    else if (employee.getDepartment() == null || employee.getDepartment().getId() == null) {
        errorMsg = "部门不能为空";
    }
    
    // 若有错误，返回添加页面并携带错误信息
    if (errorMsg != null) {
        model.addAttribute("msg", errorMsg);
        // 同时需要把部门列表再传给前端（否则下拉框会为空）
        Collection<Department> departments = departmentDao.departments();
        model.addAttribute("departments", departments);
        return "emp/add";
    }
    
    // 字段校验通过，执行添加操作
    employeeDao.addEmployee(employee);
    return "redirect:/emps";
}
```

**步骤 2：在前端页面展示错误提示**

在`emp/add.html`的表单上方添加错误信息展示区域，用于显示后端传递的`msg`。

**html**

预览

```
<!-- 在表单上方添加错误提示 -->
<div class="alert alert-danger" role="alert" th:if="${not #strings.isEmpty(msg)}">
    [[${msg}]]
</div>

<!-- 原表单代码保持不变 -->
<form class="mt-4" th:action="@{/add}" method="post">
    <!-- 其余表单内容... -->
</form>
```

**步骤 3：补充**`**@GetMapping("/add")**`**的逻辑（确保部门列表始终可用）**

为了保证 “表单回显时部门下拉框有数据”，需要在`@GetMapping("/add")`中始终传递部门列表到前端。

**java**

运行

```
@GetMapping("/add")
public String add(Model model) {
    // 查出所有部门信息，用于前端下拉框渲染
    Collection<Department> departments = departmentDao.departments();
    model.addAttribute("departments", departments);
    return "emp/add";
}
```

## 前端表单中 `name` 为 `lastname` 的字段值，如何映射到 `Employee` 对象的 `lastname` 属性上

 **Spring MVC 的参数绑定机制** 在起作用

具体流程如下：

1. **前端表单提交**：当你在图二的表单中输入姓名并提交时，表单字段 `name="lastname"` 会将输入的值以请求参数的形式发送到后端。
2. **Spring MVC 参数绑定**：后端的 `addEmp` 方法接收 `Employee` 类型的参数 `employee`，Spring MVC 会自动遍历 `Employee` 类的属性，找到与请求参数名（`lastname`）匹配的属性（`Employee` 类中对应的 `lastname` 属性），并将请求参数的值赋值给该属性。
3. **方法调用获取值**：此时，`employee` 对象的 `lastname` 属性已经被赋值，所以调用 `getLastname()` 方法就能获取到前端表单中 `name="lastname"` 对应的属性值。