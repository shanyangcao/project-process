## 流程

1. 添加功能
2. 功能对应接口
3. 思考地址请求

## problem

#### vo和entity的流程是什么

| **名称** | **说明**                                     |
| -------- | -------------------------------------------- |
| Entity   | 实体，通常和数据库中的表对应                 |
| DTO      | 数据传输对象，通常用于程序中各层之间传递数据 |
| VO       | 视图对象，为前端展示数据提供的对象           |
| POJO     | 普通Java对象，只有属性和对应的getter和setter |

1. **数据查询**：Service 层通过 Mapper 从数据库查询数据，返回 `UserEntity` 对象（含密码等敏感字段）；
2. **数据转换**：Service 层将 `UserEntity` 转换为 `UserVO`（筛选字段：剔除 password；处理字段：status 转 statusDesc；格式化字段：createTime）；
3. **响应前端**：Controller 层接收 `UserVO`，通过 JSON 序列化返回给前端，前端直接使用 VO 中的字段渲染页面。

**转换示例（Service 层代码）**

```
@Service
public class UserService {
    @Autowired
    private UserMapper userMapper;

    // 根据 ID 查询用户，返回 VO 给前端
    public UserVO getUserById(Long id) {
        // 1. 查询数据库，得到 Entity（含敏感字段 password）
        UserEntity entity = userMapper.selectById(id);
        if (entity == null) {
            throw new RuntimeException("用户不存在");
        }

        // 2. Entity 转 VO（可使用 MapStruct 框架简化转换逻辑）
        UserVO vo = new UserVO();
        vo.setUserId(entity.getId());
        vo.setUserName(entity.getUserName());
        vo.setPhone(entity.getPhone());
        vo.setStatusDesc(entity.getStatus()); // 调用 VO 中的计算逻辑
        vo.setCreateTime(entity.getCreateTime());

        return vo; // 3. 返回 VO，不含敏感字段，前端可直接使用
    }
}
```

**五、核心设计原则（避免踩坑）**

1. **Entity 不允许直接返回给前端**：避免暴露数据库结构（如主键策略、字段名）和敏感数据（如密码、加密字段），降低安全风险。
2. **VO 不允许直接传入持久层**：VO 是前端定制化结构，与数据库表无关，直接用 VO 操作数据库会导致字段不匹配、数据冗余等问题。
3. **字段按需设计**：VO 只保留前端必需的字段，减少数据传输量（如列表页不需要返回用户详情字段）。
4. **使用工具简化转换**：手动转换 Entity 和 VO 繁琐且易出错，推荐使用 `MapStruct` 框架（通过注解自动生成转换代码），提高开发效率。

#### dto是怎么传数据的，vo是怎么返回给前端的

**一、先明确核心流程**

在 Spring Boot（最常用的后端框架）中，完整流程是：`前端请求 → 后端接收DTO（入参） → 业务处理（查Entity） → 封装VO（出参） → 后端返回VO给前端`

**二、DTO：如何接收 / 传输数据（接口入参）**

DTO 作为 “接口入参载体”，核心是**前端把数据封装成 DTO 格式传给后端，后端直接接收 DTO 对象**，无需手动解析零散参数。

**1. 核心原理**

- 前端通过 JSON 格式传递参数，字段名与 DTO 的属性名一一对应；
- 后端接口方法直接声明 DTO 为入参，**Spring 框架会自动把前端的 JSON 数据 “映射” 成 DTO 对象**；
- DTO 可加参数校验注解，自动校验前端传参的合法性。

**2. 完整代码示例（用户登录场景）**

**步骤 1：定义登录 DTO（dto 包）**

```
package com.example.dto;

import lombok.Data;
import javax.validation.constraints.NotBlank;

// 登录入参DTO：只包含登录需要的字段
@Data
public class UserLoginDTO {
    // 校验：用户名不能为空，提示语返回给前端
    @NotBlank(message = "用户名不能为空")
    private String username;

    // 校验：密码不能为空
    @NotBlank(message = "密码不能为空")
    private String password;
}
```

**步骤 2：Controller 层接收 DTO（核心：直接用 DTO 当入参）**

```
package com.example.controller;

import com.example.dto.UserLoginDTO;
import com.example.service.UserService;
import com.example.vo.UserVO;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;

@RestController // 标记这是接口控制器，返回JSON
public class UserController {

    private final UserService userService;

    // 构造方法注入Service（Spring依赖注入）
    public UserController(UserService userService) {
        this.userService = userService;
    }

    // 登录接口：POST请求，路径/api/user/login
    @PostMapping("/api/user/login")
    public UserVO login(@Valid @RequestBody UserLoginDTO loginDTO) {
        // 1. @RequestBody：把前端传的JSON数据映射成UserLoginDTO对象
        // 2. @Valid：触发DTO中的参数校验（如用户名不能为空）
        // 3. 调用Service处理登录逻辑，返回VO
        return userService.login(loginDTO);
    }
}
```

**步骤 3：前端传递 DTO 数据（JSON 格式）**

前端通过 axios/request 等工具发送 POST 请求，参数是 JSON，字段名和 DTO 一致：

```
// 前端登录请求示例（JavaScript）
axios.post('/api/user/login', {
  "username": "zhangsan", // 对应DTO的username字段
  "password": "123456"    // 对应DTO的password字段
}).then(res => {
  console.log("登录成功，返回的用户信息：", res.data);
}).catch(err => {
  console.log("登录失败：", err.response.data);
});
```

**三、VO：如何返回给前端（接口出参）**

VO 作为 “前端展示载体”，核心是**后端把业务处理后的数据（如 Entity）封装成 VO 对象，Spring 自动转为 JSON 返回给前端**，前端直接用 VO 的字段渲染页面。

**1. 核心原理**

- 后端把 Entity / 其他数据的字段 “转换 / 格式化” 后封装到 VO 中（隐藏敏感字段、格式化展示字段）；
- Controller 层的方法直接返回 VO 对象，Spring 会自动把 VO 转为 JSON 格式；
- 前端接收 JSON 后，直接使用 VO 的字段（如 genderDesc、userId）展示。

**2. 完整代码示例（接上面登录场景）**

**步骤 1：定义用户 VO**

```
package com.example.vo;

import lombok.Data;
import java.time.LocalDateTime;

// 登录成功返回的VO：隐藏密码，格式化性别
@Data
public class UserVO {
    private Long userId; // 前端习惯叫userId，而非Entity的id
    private String username; // 用户名
    private String genderDesc; // 性别描述（男/女），而非Entity的gender数字
    private String phone; // 手机号（可脱敏）
    private LocalDateTime createTime; // 创建时间
    private String token; // 登录令牌（前端存储，后续请求带令牌）
    // 无password字段，避免敏感信息泄露
}
```

**步骤 2：Service 层封装 VO**

```
package com.example.service;

import com.example.dto.UserLoginDTO;
import com.example.entity.UserEntity;
import com.example.mapper.UserMapper;
import com.example.vo.UserVO;
import org.springframework.stereotype.Service;

@Service
public class UserService {

    private final UserMapper userMapper;

    public UserService(UserMapper userMapper) {
        this.userMapper = userMapper;
    }

    public UserVO login(UserLoginDTO loginDTO) {
        // 1. 根据DTO的用户名查询数据库，得到Entity（数据持久化载体）
        UserEntity userEntity = userMapper.selectByUsername(loginDTO.getUsername());

        // 2. 校验密码（省略加密校验逻辑）
        if (userEntity == null || !loginDTO.getPassword().equals(userEntity.getPassword())) {
            throw new RuntimeException("用户名或密码错误");
        }

        // 3. 把Entity转为VO（核心：定制化返回数据）
        UserVO userVO = new UserVO();
        userVO.setUserId(userEntity.getId()); // Entity的id → VO的userId
        userVO.setUsername(userEntity.getUsername());
        // 格式化性别：Entity的gender数字 → VO的文字描述
        if (userEntity.getGender() == 1) {
            userVO.setGenderDesc("男");
        } else if (userEntity.getGender() == 2) {
            userVO.setGenderDesc("女");
        } else {
            userVO.setGenderDesc("未知");
        }
        userVO.setPhone(userEntity.getPhone()); // 可脱敏：phone.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2")
        userVO.setCreateTime(userEntity.getCreateTime());
        userVO.setToken("xxx-xxx-xxx"); // 生成登录令牌

        // 4. 返回VO给Controller，最终返回给前端
        return userVO;
    }
}
```

**步骤 3：前端接收 VO 数据（直接使用）**

前端收到的 JSON 格式和 VO 字段完全一致，可直接渲染：

```
// 前端收到的VO JSON数据
{
  "userId": 1,
  "username": "zhangsan",
  "genderDesc": "男",
  "phone": "13812345678",
  "createTime": "2026-01-19 10:00:00",
  "token": "xxx-xxx-xxx"
}
```

```
// 前端渲染示例
axios.post('/api/user/login', {username: "zhangsan", password: "123456"})
  .then(res => {
    // res.data就是VO对应的JSON
    document.getElementById("username").innerText = res.data.username;
    document.getElementById("gender").innerText = res.data.genderDesc;
    // 存储令牌，供后续请求使用
    localStorage.setItem("token", res.data.token);
  });
```

**四、简化转换：使用工具类（进阶）**

实际开发中，手动 set 字段太繁琐，可使用`MapStruct`（推荐）/`BeanUtils`工具自动转换 Entity→VO、DTO→Entity：

```
// MapStruct示例：定义转换接口，自动生成转换代码
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

@Mapper(componentModel = "spring")
public interface UserConvert {
    // Entity转VO：指定字段映射，格式化性别
    @Mapping(source = "id", target = "userId")
    @Mapping(target = "genderDesc", expression = "java(userEntity.getGender() == 1 ? \"男\" : (userEntity.getGender() == 2 ? \"女\" : \"未知\"))")
    UserVO entityToVO(UserEntity userEntity);
}
```

#### 添加员工显示服务器错误

```
@Insert("insert into employee(name,username,password,phone,sex,id_number,status,create_time,update_time,create_user,update_user)"+
        "values"+
        "(#(name),#(username),#(password),#(phone),#(sex),#(idNumber),#(status),#(createTime),#(updateTime),#(createUser),#(updateUser))")
```

上面代码块字段不是括号，要花括号

#### 日期格式化有哪些方法

![img](https://cdn.nlark.com/yuque/0/2025/png/56763514/1764069193199-27ba0071-c5ce-4a69-9e95-10ad64e1f651.png)

#### 为什么执行@AutoFill(OperationType.INSERT)下面的函数，就会被图中的autoFill函数拦截![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768750945060-ab39c6f5-db57-4e2d-a37b-10bb3ee3ae89.png)

1. `AutoFillAspect` 类上标注了 `@Aspect`，这告诉 Spring 这是一个**切面类**，里面定义了拦截规则和增强逻辑。

`@Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")`

- `execution(* com.sky.mapper.*.*(..))`：匹配 `com.sky.mapper` 包下的所有类的所有方法。
- `&& @annotation(com.sky.annotation.AutoFill)`：进一步要求目标方法上**必须标注了** `**@AutoFill**` **注解**。两者结合，就定义了一个精确的拦截范围：只有 `com.sky.mapper` 包下、且方法上带有 `@AutoFill` 注解的方法，才会被这个切入点选中。

1. `autoFill` 方法上标注了 `@Before("autoFillPointCut()")`，这表示：

- - 当目标方法匹配 `autoFillPointCut()` 这个切入点时，**在目标方法执行之前**，会先执行 `autoFill` 方法。


- 所以，当你调用一个带有 `@AutoFill(OperationType.INSERT)` 注解的 `mapper` 方法时，Spring AOP 会检测到它匹配了切入点，就会自动触发 `autoFill` 方法，实现 “拦截” 并执行公共字段填充。

#### 当admin包和user包有相同名字的controller类编译错误怎么办

在注解@RestController修改bean的名字

```
//admin包下
@RestController("adminShopController")
//user包下
@RestController("userShopController")
```

#### 什么时候用redis存储，什么时候用mysql创建表存储

**一、用 Redis 存储的场景**

Redis 数据默认存在内存中（可配置持久化），读写速度极快（百万级 QPS），但内存成本高、不擅长复杂关系查询，适合存储这些数据：

**1. 高频访问的 “热点数据”（缓存）**

这是 Redis 最核心的使用场景，目的是减轻 MySQL 压力、提升接口响应速度。

- 示例：


- - 电商首页的商品列表、商品详情页数据（访问量极大，每次都查 MySQL 会拖慢速度）；
  - 网站的热门文章、排行榜数据（如 “销量 Top10”）；
  - 用户登录后的信息（如 Token、用户基本信息），替代频繁查 MySQL。


- 逻辑：先查 Redis → 有数据直接返回；无数据查 MySQL → 查到后写入 Redis → 返回给前端，同时设置过期时间（避免数据不一致）。

**2. 临时 / 时效性数据**

数据不需要长期存储，或有明确过期时间，适合用 Redis 的过期策略管理：

- 示例：


- - 短信验证码（设置 5 分钟过期，自动失效）；
  - 用户登录的 Token（设置 2 小时过期，实现自动登出）；
  - 秒杀活动的库存计数（临时计数，活动结束后可丢弃）。

**3. 需要高性能读写的场景**

对读写速度要求极高，MySQL 无法满足的场景：

- 示例：


- - 实时计数器（文章阅读量、视频播放量、点赞数，Redis 的 `INCR/DECR` 命令原子性且超快）；
  - 排行榜 / 榜单（Redis 的 `Sorted Set` 结构可轻松实现按分数排序、实时更新）；
  - 分布式锁（解决多服务并发问题，如秒杀下单防超卖）；
  - 消息队列（简单的生产消费场景，如异步发送短信）。

**4. 非结构化 / 半结构化数据**

数据格式不适合用 MySQL 表结构存储的场景：

- 示例：


- - 临时的用户会话数据（如购物车临时商品，结构灵活）；
  - 复杂的缓存数据（如嵌套的用户权限信息，Redis 支持 Hash/List 等结构，无需拆表）。

**二、用 MySQL 创建表存储的场景**

MySQL 基于磁盘存储，支持复杂的关系模型、事务（ACID）、索引和 SQL 查询，适合存储核心业务数据：

**1. 核心业务数据（需持久化、可追溯）**

数据是业务的 “根基”，必须长期保存且不能丢失，需要事务保证一致性：

- 示例：


- - 用户账号信息（用户名、加密密码、手机号）；
  - 订单数据（订单号、金额、支付状态、收货地址）；
  - 商品基础信息（名称、价格、库存、分类，需长期稳定存储）；
  - 财务数据（支付记录、退款记录，需精准且可审计）。

**2. 结构化数据（需复杂查询 / 关联）**

数据有明确的表结构，需要多表关联、条件筛选、分组统计等复杂查询：

- 示例：


- - 电商的订单查询（需关联用户表、商品表、支付表，筛选 “近 3 个月未付款的订单”）；
  - 企业的客户管理（需按地区、行业、成交金额分组统计）；
  - 学生成绩管理（需按班级、科目、分数范围查询）。

**3. 数据量较大且访问频率不高的场景**

数据量超过内存承载能力，且访问频率低，用磁盘存储更经济：

- 示例：


- - 历史订单数据（超过 1 年的订单，极少访问，可存在 MySQL 归档表）；
  - 系统操作日志（需长期留存，但查询频率低）。

**4. 需要事务 / 数据一致性的场景**

操作需要保证原子性（要么全成，要么全败），MySQL 的事务机制是核心优势：

- 示例：


- - 支付扣款（扣用户余额 + 生成支付记录，必须同时成功）；
  - 下单减库存（创建订单 + 扣商品库存，防止超卖）。

**典型配合示例（电商下单）**

1. 用户下单时，先查 Redis 中的商品库存（热点数据，快）；
2. 扣减 Redis 中的库存（原子操作，防止并发超卖）；
3. 发起 MySQL 事务：创建订单记录 + 扣减 MySQL 中的商品库存（持久化，保证数据最终一致）；
4. 若 MySQL 事务失败，回滚 Redis 中的库存；若成功，订单数据长期存在 MySQL，Redis 仅缓存订单摘要供前端快速查询。

**总结**

1. **Redis**：管 “快” 和 “临时”，核心是高性能缓存、高频读写、临时数据、非结构化数据，是 MySQL 的 “加速器”；
2. **MySQL**：管 “稳” 和 “持久”，核心是结构化、持久化、复杂查询、事务性的核心业务数据，是数据的 “最终存储地”；
3. 实际开发中二者几乎必配合：Redis 缓存 MySQL 的热点数据提升性能，MySQL 存储核心数据保证一致性，Redis 不适合作为核心数据的唯一存储（内存易失，持久化仅作备份）。

### 思想

#### 字段填充

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768746853638-7d923358-0a74-4f82-bd1f-57ac4dd450a1.png)

在**注解**通知的第一步，判断拦截的方法的数据库操作类型，是Insert还是Update并赋值进行下一步判断，判断的类型是**枚举**来显示的

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768753148505-d552bdf6-04c9-4f7d-b01a-a3ad6ffc50b7.png)

第二步，拿出拦截方法的第一个参数对象也进行赋值，对象的属性需要更改

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768753268180-3da50adf-9349-4447-a2f2-c133966ae464.png)

第三步，先判断是哪个操作，在改数据库操作的基础上，将获取的对象通过**反射**进行更改

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768753375035-ce670992-0f39-4aab-a047-b34c172b5ba7.png)

#### 新增菜品

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768753769859-0c591d86-f2d7-4893-9eca-0ad2eb7cec83.png)

首先新增菜品用了切面的新注解

#### 分页查询

#### 删除菜品

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768836506074-780f7bf2-30b6-4aa7-9aee-491ee8f79c37.png)

#### 修改菜品

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768837856972-24793623-1e99-49b4-b0d5-aba8a89a017f.png)

#### redis书写流程

通过RedisTemplate对象操作Redis，redis是写在config包下的

```
@Configuration
@Slf4j
public class RedisConfiguration {
    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
        log.info("开始创建redis模板对象...");
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis key的序列化器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    }
}
```

redisTemplate有很多方法，可以分别转换为不同数据类型

```
 ValueOperations valueOperations = redisTemplate.opsForValue();
        HashOperations hashOperations = redisTemplate.opsForHash();
        ListOperations listOperations = redisTemplate.opsForList();
        ZSetOperations zSetOperations = redisTemplate.opsForZSet();
```

并且还可以通过这个数据类型进行set，get等操作

```
@Test
public void testHash(){
    //hset hget hkeys hvals
    HashOperations hashOperations = redisTemplate.opsForHash();
    hashOperations.put("100","name","tom"); //相当于hset
    hashOperations.put("100","age","20");
    String name = (String)hashOperations.get("100", "name"); //相当于hget
    System.out.println(name);
    Set keys = hashOperations.keys("100"); //相当于hkeys
    System.out.println(keys);
    List values = hashOperations.values("100"); //相当于hvals
    System.out.println(values);
    hashOperations.delete("100","age");//相当于hdel
    
}
```

key不能重复放set，value可以重复索引放list

#### 营业状态

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768914984067-abbd571f-3337-4be0-b140-e2e1efeb5486.png)

![img](https://cdn.nlark.com/yuque/0/2026/png/56763514/1768914994322-bc6118f2-3115-4855-bcad-fddfc93f7947.png)